---
layout: post
title: "数据结构"
date: 2016-06-15
categories: shujujiegou
featured_image: /images/cover.jpg
---

##有向图的出度计算

------
--代码展示
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,a[100][100]={0},b[100]={0};
	cin>>n;
	for(i=0;i<n;i++)//输入数据
	{
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(i=0;i<n;i++)//判断是否为邻接
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]==1)
				b[i]++;
		}
	}
	for(i=0;i<n;i++)
	{
		cout<<b[i]<<endl;
	}
	return 0;
}
------

##有向图的最大出度计算

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,m,i,a[100]={0},b[100]={0},c[100]={0},sum=0;
	cin>>n;
	cin>>m;
	for(i=0;i<m;i++)//输入数据
	{
		scanf("%d %d",&a[i],&b[i]);
		c[a[i]]++;
	}
	for(i=0;i<n;i++)//找出最大出度
	{
		if(c[i+1]>c[i])
		{
			sum=c[i+1];
		}
	}
	cout<<sum<<endl;
	for(i=0;i<n;i++)//找出最大出度所对应的数据
	{
		if(c[i]==sum)
		{
			cout<<i;
		}
	}
	return 0;
}
-------

##无向图的最大出度计算

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,a[100][100]={0},b[100]={0};
	cin>>n;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]==1)
				b[i]++;
		}
	}
	int sum=0;
	for(i=0;i<n;i++)
	{
		if(b[i+1]>b[i])
			sum=b[i+1];
	}
	cout<<sum<<endl;
	for(i=0;i<n;i++)
	{
		if(b[i]==sum)
			cout<<i;
	}
	return 0;
}
-------

##有向图的k出度计算

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,k,i,j,a[100][100]={0},b[100]={0};
	cin>>n;
	cin>>k;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]==1)
				b[i]++;
		}
	}
	int count=0;
	for(i=0;i<n;i++)
	{
		if(b[i]==k)
		{
			count++;
		}
	}
	cout<<count<<endl;
	for(i=0;i<n;i++)
	{
		if(b[i]==k)
			cout<<i;
	}
	return 0;
}
-------

##有向图的边存在判断

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,k,r,a[100][100]={0};
	cin>>n;
	cin>>k>>r;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(i==k&&j==r)
			{
				if(a[i][j]==0)
					cout<<"no";
				else
					cout<<"yes";
			}
		}
	}
	return 0;
}
-------

##带权有向图的计算

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,a[100][100]={0};
	int max=0,mini=1000;//这是等会要跟数据比较的
	cin>>n;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
			cin>>a[i][j];
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(max<a[i][j])
				max=a[i][j];
		}
	}
	cout<<max<<endl;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]==max)
			{
				cout<<"<"<<i<<' '<<j<<">";
			}
		}
	}
	cout<<endl;
		for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]<mini&&a[i][j]>0)
				mini=a[i][j];
		}
	}
	cout<<mini<<endl;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]==mini)
			{
				cout<<"<"<<i<<' '<<j<<">";
			}
		}
	}
	return 0;
}
-------

##带权无向图存储判定（对称矩阵的判定）

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,a[100][100]={0};
	int k=0;//记录矩阵的大小
	cin>>n;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
			cin>>a[i][j];
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			if(a[i][j]==a[j][i])//这句比较重要
			{
				k++;
			}
		}
	}
	if(k==n*n)//如果还是大小不变，那么就是对称的
		cout<<"yes";
	else
		cout<<"no";
	return 0;
}
-------

##无向图的连通分量的计算

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int a[100][100]={0},n,visited[100]={0};
int count=0;//记录连通分量的个数
void DFS(int k)
{
	int i;
	visited[k]=1;//现在正在访问，所以改为1
	for(i=0;i<n;i++)
	{
		if(a[k][i]!=0&&visited[i]==0)//这是被访问的点是邻接的，而且是未被访问过的
			DFS(i);
	}
}	
int main()
{
	int i,j;
	cin>>n;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(i=0;i<n;i++)
	{
		if(visited[i]==0)//表示该节点是未被访问的
		{
			DFS(i);
			count++;
		}
	}
	cout<<count;
	return 0;
}
-------

##图的按录入顺序深度优先搜索

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int a[100][100]={0},n,visited[100]={0};
char s[100];
void DFS(int k)//深度搜索
{
	int i;
	visited[k]=1;
	cout<<s[k];
	for(i=0;i<n;i++)
	{
		if(a[k][i]!=0&&visited[i]==0)
			DFS(i);
	}
}
int main()
{
	int i,j,k;
	char ch;
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>s[i];
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cin>>a[i][j];
		}
	}
	cin>>ch;
	for(i=0;i<n;i++)//找到那个字符，然后就是把那个字符的坐标当作下一个访问的对象
	{
		if(s[i]==ch)
			k=i;
	}
	DFS(k);
	return 0;
}
-------

##图的按录入顺序广度搜索

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int a[100][100]={0},n,visited[100]={0};
char s[100];
void BFS(int k)//广度搜索
{
	int j,w;
	int q[100];
	int front,rear;
	front=rear=0;
	visited[k]=1;
	cout<<s[k];
	rear=(rear+1)%100;
	q[rear]=k;
	while(front!=rear)
	{
		front=(front+1)%100;
		w=q[front];
		for(j=0;j<n;j++)
		{
			if(a[w][j]!=0&&visited[j]==0)
			{
				cout<<s[j];
				visited[j]=1;
				rear=(rear+1)%100;
				q[rear]=j;
			}
		}
	}
}
int main()
{
	int i,j,k;
	char ch;
	cin>>n;
	for(i=0;i<n;i++)
		cin>>s[i];
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
			cin>>a[i][j];
	}
	cin>>ch;
	for(i=0;i<n;i++)
	{
		if(s[i]==ch)
			k=i;
	}
	BFS(k);
	return 0;
}

-------

##层次遍历

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
typedef struct node
{
	char data;
	struct node *lchild;
	struct node *rchild;
}btnode;
void pre(btnode *&r)
{
	char ch;
	ch=getchar();
	if(ch=='#')r=NULL;
	else
	{
		r=(btnode *)malloc(sizeof(btnode));
		r->data=ch;
		pre(r->lchild);
		pre(r->rchild);
	}
}
void cengci(btnode *&t)
{
	btnode *qu[1000];
	btnode *p;
	int front,rear;
	front=rear=-1;
	rear++;
	qu[rear]=t;
	while(front!=rear)
	{
		front=(front+1)%100;
		p=qu[front];
		cout<<p->data;
		if(p->lchild!=NULL)
		{
			rear=(rear+1)%100;
			qu[rear]=p->lchild;
		}
		if(p->rchild!=NULL)
		{
			rear=(rear+1)%100;
			qu[rear]=p->rchild;
		}
	}
}
int main()
{
	btnode *t;
	pre(t);
	cengci(t);
	return 0;
}
-------

##折半查找

-------
#include<stdlib.h>
#include<iostream>
using namespace std;
int s=0;
int mid(int a[],int low,int heigh,int k)
{
	int maid;
	maid=(low+heigh)/2;
	s++;
	if(low==heigh)
	{
		cout<<"-1"<<endl;
		cout<<s;
	}
	else if(a[maid]==k)
	{
		cout<<maid<<endl;
		cout<<s;
	}
	else if(a[maid]>k)
	{
		heigh=maid-1;
		mid(a,low,heigh,k);
	}
	else
	{
		low=maid+1;
		mid(a,low,heigh,k);
	}
	return 0;
}
int main()
{
	int n,i,k,low,heigh,a[1000];
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
	}
	cin>>k;
	low=0;heigh=n-1;
	mid(a,low,heigh,k);
	return 0;
}
-------

##交换排序算法的设计和实现-冒泡排序

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
int main()
{
	int n,i,j,tmp,a[100]={0};
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
	}
	for(i=0;i<n;i++)//冒泡排序的精华
	{
		for(j=0;j<n-1-i;j++)
		{
			if(a[j]>a[j+1])
			{
				tmp=a[j+1];
				a[j+1]=a[j];
				a[j]=tmp;
			}
		}
		break;
	}
	for(i=0;i<n;i++)
	{
		cout<<a[i]<<' ';
	}
	return 0;
}
-------

##堆排序算法

-------
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
void sift(int a[],int low,int heigh)
{
	int i=low,j=2*i;
	int tmp=a[low];
	while(j<=heigh)
	{
		if(j<heigh&&a[j]>a[j+1])
			j++;
		if(tmp>a[j])
		{
			a[i]=a[j];
			i=j;
			j=2*i;
		}
		else break;
	}
	a[i]=tmp;
}
void create(int a[],int n)
{
	int i;
	for(i=n/2;i>=1;i--)
	{
		sift(a,i,n);
	}
}
int main()
{
	int n,i,a[100];
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	create(a,n);
	for(i=1;i<=n;i++)
	{
		cout<<a[i]<<' ';
	}
	return 0;
}
-------